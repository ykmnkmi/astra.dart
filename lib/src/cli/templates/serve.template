import 'dart:async';
import 'dart:developer';
import 'dart:io';
import 'dart:isolate';

import 'package:astra/cli.dart';
import 'package:astra/core.dart';
import 'package:astra/middlewares.dart';
import 'package:astra/isolate.dart';
import 'package:astra/serve.dart';
import 'package:path/path.dart';
import 'package:stream_transform/stream_transform.dart';
import 'package:vm_service/vm_service_io.dart';

import '__PACKAGE__' as _ show __TARGET__;

const bool isApplication = __ISAPPLICATION__;

const int concurrency = __CONCURRENCY__;

const bool hotReload = __RELOAD__;

const bool observe = __OBSERVE__;

const String scheme = '__SCHEME__';

const String address = '__ADDRESS__';

const int port = __PORT__;

const int backlog = __BACKLOG__;

const bool shared = __SHARED__;

const bool v6Only = __V6ONLY__;

__CREATE__

Future<void> main() async {
  if (observe) {
    var info = await Service.getInfo();
    var uri = info.serverUri;

    if (uri == null) {
      // TODO: update error
      throw StateError('observe: no server uri');
    }

    stdout.writeln('* observatory listening on $uri');
  }

  var shutdown = <FutureOr<void> Function()>[];
  var supervisors = <IsolateSupervisor>[];

  for (var i = 0; i < concurrency; i += 1) {
    var receivePort = RawReceivePort();
    var isolate = await Isolate.spawn(create, receivePort.sendPort, //
        paused: true,
        errorsAreFatal: false,
        onError: receivePort.sendPort,
        debugName: 'isolate/${i + 1}');
    var supervisor = IsolateSupervisor(isolate, receivePort, i);
    stdout.writeln('* starting isolate/${i + 1}');
    await supervisor.resume();
    supervisors.add(supervisor);
  }

  Future<void> stopAll() {
    return Future.wait<void>(supervisors.map<Future<void>>((supervisor) => supervisor.stop()));
  }

  shutdown.add(stopAll);

  if (concurrency == 1) {
    stdout.writeln('* isolate started');
  } else {
    stdout.writeln('* all isolates started');
  }

  var controller = StreamController<Object>(sync: true);

  FutureOr<void> Function() reload;

  if (hotReload) {
    var info = await Service.getInfo();
    var uri = info.serverWebSocketUri;

    if (uri == null) {
      // TODO: update error
      throw CliException('reload: no vm service ws uri');
    }

    var service = await vmServiceConnectUri(uri.toString());
    shutdown.add(service.dispose);

    var isolateIds = <String>[];

    for (var supervisor in supervisors) {
      var id = Service.getIsolateID(supervisor.isolate);

      if (id == null) {
        throw CliException('isolate/${supervisor.identifier} id == null');
      }

      isolateIds.add(id);
    }

    var directory = Directory('lib');

    reload = () async {
      stdout.writeln('* hot reloading ...');

      Future<void> reload(String isolateId) async {
        var result = await service.reloadSources(isolateId);

        if (isApplication && result.success == true) {
          await service.callServiceExtension('ext.astra.reload', isolateId: isolateId);
        }
      }

      await Future.wait<void>(isolateIds.map(reload));

      if (concurrency == 1) {
        stdout.writeln('* isolate reloaded');
      } else {
        stdout.writeln('* $concurrency isolate(s) reloaded');
      }
    };

    var watch = directory.watch(events: FileSystemEvent.modify, recursive: true).listen(controller.add);
    shutdown.add(watch.cancel);
    stdout.writeln('* watching ${toUri(directory.path).toFilePath(windows: false)}');
  } else {
    reload = () {
      stdout.writeln('* hot reload not enabled');
    };
  }

  var stdinSubscription = stdin.map<String>(String.fromCharCodes).listen(controller.add);
  shutdown.add(stdinSubscription.cancel);

  var sigintSubscription = ProcessSignal.sigint.watch().listen(controller.add);
  shutdown.add(sigintSubscription.cancel);

  stdout.writeln('* serving at $scheme://$address:$port ...');

  await for (var event in controller.stream) {
    if (event is FileSystemEvent || event == 'r') {
      await reload();
      continue;
    }

    if (event == 'R') {
      stdout.writeln('* hot restart not implemented');
      continue;
    }

    if (event is ProcessSignal || event == 'q') {
      stdout.writeln('* closing ...');

      for (var callback in shutdown.reversed) {
        await callback();
      }

      break;
    }

    if (event == 'Q') {
      stdout.writeln('* exit');
      exit(0);
    }

    if (event is String) {
      stdout.writeln('* unknown key: \'$event\', ${event.runes}');
    } else {
      stdout.writeln('* unknown event: $event');
    }
  }
}

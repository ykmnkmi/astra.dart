import 'dart:async';
import 'dart:developer';
import 'dart:io';
import 'dart:isolate';

import 'package:astra/core.dart';
import 'package:astra/middlewares.dart';
import 'package:astra/isolate.dart';
import 'package:astra/serve.dart';
import 'package:path/path.dart';
import 'package:stream_transform/stream_transform.dart';
import 'package:vm_service/vm_service_io.dart';

import '__PACKAGE__' as _ show __TARGET__;

const bool isApplication = __ISAPPLICATION__;

const int concurrency = __CONCURRENCY__;

const bool reload = __RELOAD__;

const bool oboserve = __OBSERVE__;

const String scheme = '__SCHEME__';

const String address = '__ADDRESS__';

const int port = __PORT__;

const int backlog = __BACKLOG__;

const bool shared = __SHARED__;

const bool v6Only = __V6ONLY__;

__CREATE__

Future<void> main() async {
  if (oboserve) {
    var info = await Service.getInfo();
    var uri = info.serverUri;

    if (uri == null) {
      // TODO: update error
      throw StateError('observe: no server uri');
    }

    stdout.writeln('* observatory listening on $uri');
  }

  var shutdown = <FutureOr<void> Function()>[];
  var supervisors = <IsolateSupervisor>[];

  for (var i = 0; i < concurrency; i += 1) {
    var receivePort = RawReceivePort();
    var isolate = await Isolate.spawn(create, receivePort.sendPort, //
        paused: true,
        errorsAreFatal: false,
        onError: receivePort.sendPort,
        debugName: 'isolate/${i + 1}');

    var supervisor = IsolateSupervisor(isolate, receivePort, i);
    stdout.writeln('* starting isolate/${i + 1}');
    await supervisor.resume();
    supervisors.add(supervisor);
    shutdown.add(supervisor.stop);
  }

  if (concurrency > 1) {
    stdout.writeln('* all isolates started');
  } else {
    stdout.writeln('* isolate started');
  }

  if (reload) {
    var info = await Service.getInfo();
    var uri = info.serverWebSocketUri;

    if (uri == null) {
      // TODO: update error
      throw Exception('reload: no vm service ws uri');
    }

    var service = await vmServiceConnectUri(uri.toString());
    shutdown.add(service.dispose);

    var isolateIds = <String>[];

    for (var supervisor in supervisors) {
      var id = Service.getIsolateID(supervisor.isolate);

      if (id == null) {
        throw CliException('isolate/${supervisor.identifier} id == null');
      }

      isolateIds.add(id);
    }

    var directory = Directory('lib');

    Future<void> reloading(FileSystemEvent event) async {
      stdout.writeln('* reloading...');

      Future<void> reload(String isolateId) async {
        var result = await service.reloadSources(isolateId);

        if (isApplication && result.success == true) {
          await service.callServiceExtension('ext.astra.reload', isolateId: isolateId);
        }
      }

      await Future.wait<void>(isolateIds.map(reload));
    }

    void reloaded(Object? message) {
      if (concurrency > 1) {
        stdout.writeln('* $concurrency isolate(s) reloaded');
      } else {
        stdout.writeln('* isolate reloaded');
      }
    }

    var watch = directory
        .watch(events: FileSystemEvent.modify, recursive: true)
        .throttle(Duration(seconds: 1))
        .asyncMapSample<void>(reloading)
        .listen(reloaded);
    shutdown.add(watch.cancel);
    stdout.writeln('* watching ${toUri(directory.path).toFilePath(windows: false)}');
  }

  stdout.writeln('* serving at $scheme://$address:$port');

  await for (var bytes in stdin) {
    var input = String.fromCharCodes(bytes).trimRight();

    if (input == 'Q' || input == 'q') {
      await Future.forEach<FutureOr<void> Function()>(shutdown.reversed, (callback) => callback());
      break;
    }
  }
}

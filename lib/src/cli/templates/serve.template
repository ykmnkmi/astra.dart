// generated by Astra CLI __VERSION__ serve command.
//
// ignore_for_file: depend_on_referenced_packages
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: library_prefixes

import 'dart:async';
import 'dart:developer';
import 'dart:io';
import 'dart:isolate';

import 'package:astra/cli.dart';
import 'package:astra/core.dart';
import 'package:astra/isolate.dart';
import 'package:astra/serve.dart';
import 'package:stream_transform/stream_transform.dart';
import 'package:vm_service/vm_service_io.dart';

import '__PACKAGE__' as _ show __TARGET__;

const ServerType serverType = __SERVERTYPE__;

const int concurrency = __CONCURRENCY__;

const bool observe = __OBSERVE__;

const bool hotReload = __RELOAD__;

const bool watchLib = __WATCH__;

const bool verbose = __VERBOSE__;

const bool asserts = __ASSERTS__;

const String scheme = '__SCHEME__';

const String address = '__ADDRESS__';

const int port = __PORT__;

const int backlog = __BACKLOG__;

const bool shared = __SHARED__;

const bool v6Only = __V6ONLY__;

__CREATE__

Future<void> main(List<String> arguments) async {
  var overriden = arguments.isNotEmpty && arguments.contains('--overriden');

  if (observe) {
    var info = await Service.getInfo();
    var uri = info.serverUri;

    if (uri == null) {
      throw CliException('observe: no server uri');
    }

    stdout.writeln('* observatory listening on $uri');
  }

  var shutdown = <FutureOr<void> Function()>[];
  var supervisors = <IsolateSupervisor>[];

  var controller = StreamController<Object>(sync: true);

  Future<void> Function() reload, restart;

  Future<void> startAll() async {
    for (var i = 0; i < concurrency; i += 1) {
      var receivePort = RawReceivePort();
      var isolate = await Isolate.spawn(create, receivePort.sendPort, //
          paused: true,
          errorsAreFatal: false,
          onError: receivePort.sendPort,
          debugName: 'isolate/${i + 1}');
      var supervisor = IsolateSupervisor(isolate, receivePort);
      supervisors.add(supervisor);
      await supervisor.resume();
    }

    if (concurrency == 1) {
      stdout.writeln('* isolate started');
    } else {
      stdout.writeln('* all isolates started');
    }
  }

  Future<void> stopAll() {
    Future<void> stop(IsolateSupervisor supervisor) {
      return supervisor.stop();
    }

    return Future.wait<void>(supervisors.map<Future<void>>(stop));
  }

  Future<void> shutDownAll() async {
    for (var callback in shutdown.reversed) {
      await callback();
    }
  }

  if (hotReload) {
    var info = await Service.getInfo();
    var uri = info.serverWebSocketUri;

    if (uri == null) {
      throw CliException('reload: no vm service ws uri');
    }

    var service = await vmServiceConnectUri('$uri');
    shutdown.add(service.dispose);

    var isolateIds = <String>[];

    for (var supervisor in supervisors) {
      var id = Service.getIsolateID(supervisor.isolate);

      if (id == null) {
        throw CliException('${supervisor.isolate.debugName} id == null');
      }

      isolateIds.add(id);
    }

    var directory = Directory('lib');

    reload = () async {
      stdout.writeln('* hot reloading ...');

      Future<void> reload(String isolateId) async {
        var result = await service.reloadSources(isolateId);

        if (result.success == true) {
          await service.callServiceExtension('ext.astra.reload', isolateId: isolateId);
        }
      }

      await Future.wait<void>(isolateIds.map<Future<void>>(reload));

      if (concurrency == 1) {
        stdout.writeln('* isolate reloaded');
      } else {
        stdout.writeln('* $concurrency isolate(s) reloaded');
      }
    };

    if (watchLib) {
      var watch = directory
          .watch(events: FileSystemEvent.modify, recursive: true)
          .throttle(Duration(seconds: 1))
          .listen(controller.add);
      shutdown.add(watch.cancel);
      stdout.writeln('* watching ${directory.uri}');
    }

    restart = () async {
      stdout.writeln('* hot restarting ...');
      await stopAll();
      supervisors = <IsolateSupervisor>[];
      await startAll();
    };
  } else {
    reload = () async {
      stdout.writeln('* hot reload not enabled');
    };

    restart = () async {
      stdout.writeln('* hot restart not enabled');
    };
  }

  shutdown.add(stopAll);

  await startAll();

  late bool echoMode, lineMode;

  if (!overriden) {
    echoMode = stdin.echoMode;
    lineMode = stdin.lineMode;

    stdin
      ..echoMode = false
      ..lineMode = false;
  }

  try {
    var stdinSubscription = stdin.map<String>(String.fromCharCodes).listen(controller.add);
    shutdown.add(stdinSubscription.cancel);

    var sigintSubscription = ProcessSignal.sigint.watch().listen(controller.add);
    shutdown.add(sigintSubscription.cancel);

    stdout.writeln('* serving at $scheme://$address:$port');

    await for (var event in controller.stream) {
      if (event is String) {
        event = event.trim();
      }

      // from keyboard or file system
      if (event == 'r' || event is FileSystemEvent) {
        await reload();
        continue;
      }

      // from keyboard
      if (event == 'R') {
        await restart();
        continue;
      }

      // from keyboard, parent or process signal
      if (event == 'q' || event == 'SIGINT' || event == 'SIGTERM' || event is ProcessSignal) {
        stdout.writeln('* closing ...');
        await shutDownAll();
        break;
      }

      // from keyboard
      if (event == 'Q') {
        stdout.writeln('* exiting imediate');
        exit(0);
      }

      if (event is String) {
        stdout.writeln('* unknown key: \'$event\', ${event.runes}');
      } else {
        stdout.writeln('* unknown event: $event');
      }
    }
  } finally {
    if (!overriden) {
      stdin
        ..echoMode = echoMode
        ..lineMode = lineMode;
    }
  }
}

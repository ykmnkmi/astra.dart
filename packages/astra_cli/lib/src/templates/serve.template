// generated by astra CLI __VERSION__ serve command.
//
// ignore_for_file: no_leading_underscores_for_library_prefixes

import 'dart:async';
import 'dart:convert';
import 'dart:developer';
import 'dart:io';
import 'dart:isolate';

import 'package:astra/core.dart';
import 'package:astra/isolate.dart';
import 'package:astra/serve.dart';

import '__PACKAGE__' as _ show __TARGET__;

Future<void> create(SendPort sendPort) async {
  Application application;

  if (_.__TARGET__ case Application target) {
    application = target;
  } else if (_.__TARGET__ case Future<Application> future) {
    application = await future;
  } else if (_.__TARGET__ case Application Function() factory) {
    application = factory();
  } else if (_.__TARGET__ case Future<Application> Function() factory) {
    application = await factory();
  } else if (_.__TARGET__ case Handler handler) {
    application = handler.asApplication();
  } else if (_.__TARGET__ case Future<Handler> future) {
    var handler = await future;
    application = handler.asApplication();
  } else {
    throw UnsupportedError('${_.application.runtimeType}');
  }

__SERVE__
}

Future<IsolateSupervisor> start(int index) async {
  var supervisor = await IsolateSupervisor.spawn(create, 'server/$index');
  await supervisor.resume();
  return supervisor;
}

Future<List<IsolateSupervisor>> startAll() async {
  var futures = List<Future<IsolateSupervisor>>.generate(__CONCURRENCY__, start);
  return await Future.wait<IsolateSupervisor>(futures);
}

Future<void> stop(IsolateSupervisor supervisor) async {
  await supervisor.stop();
}

Future<void> stopAll(List<IsolateSupervisor> supervisors) async {
  var futures = supervisors.map<Future<void>>(stop);
  await Future.wait<void>(futures);
}

Future<void> kill(IsolateSupervisor supervisor) async {
  await supervisor.kill();
}

Future<void> killAll(List<IsolateSupervisor> supervisors) async {
  var futures = supervisors.map<Future<void>>(kill);
  await Future.wait<void>(futures);
}

String? getIsolateSupervisorID(IsolateSupervisor supervisor) {
  return Service.getIsolateID(supervisor.isolate);
}

ServiceExtensionResponse okResponse({Map<String, Object?>? data}) {
  var result = <String, Object?>{...?data};
  return ServiceExtensionResponse.result(json.encode(result));
}

ServiceExtensionResponse errorResponse(Object error, StackTrace stackTrace) {
  var result = <String, Object?>{'error': '$error', 'stackTrace': '$stackTrace'};
  return ServiceExtensionResponse.error(
    ServiceExtensionResponse.extensionError,
    json.encode(result),
  );
}

extension on Application {
  void register() {
    registerExtension('ext.astra.reload', (isolate, data) async {
      try {
        await reload();
        return okResponse();
      } catch (error, stackTrace) {
        return errorResponse(error, stackTrace);
      }
    });
  }
}

Future<void> main(List<String> arguments) async {
  var info = await Service.getInfo();
  var socketUri = info.serverWebSocketUri;
  var isolateID = Service.getIsolateID(Isolate.current);
  var supervisors = await startAll();
  var isolates = supervisors.map(getIsolateSupervisorID).toList();
  stdout.writeln('$socketUri,$isolateID,${isolates.join(',')}');

  registerExtension('ext.astra.restart', (isolateId, params) async {
    await stopAll(supervisors);
    supervisors = await startAll();
    isolates = supervisors.map(getIsolateSupervisorID).toList();

    var data = <String, Object?>{'isolates': isolates};
    return okResponse(data: data);
  });

  registerExtension('ext.astra.close', (isolateId, params) async {
    await stopAll(supervisors);
    return okResponse();
  });

  registerExtension('ext.astra.kill', (isolateId, params) async {
    await killAll(supervisors);
    return okResponse();
  });
}

// generated by astra CLI __VERSION__ serve command.
//
// ignore_for_file: no_leading_underscores_for_library_prefixes

import 'dart:async';
import 'dart:convert';
import 'dart:developer';
import 'dart:io';
import 'dart:isolate';

import 'package:astra/core.dart';
import 'package:astra/isolate.dart';
import 'package:astra/serve.dart';

import '__PACKAGE__' as _ show __TARGET__;

void create(SendPort sendPort) {
  var debugName = Isolate.current.debugName ?? 'server/x';

  Future<void> body() async {
__CREATE__
__SERVE__
  }

  runZoned<void>(
    body,
    zoneSpecification: ZoneSpecification(
      print: (self, parent, zone, message) {
        parent.print(zone, '$debugName: $message');
      },
    ),
  );
}

Future<IsolateSupervisor> start(int index) async {
  var supervisor = await IsolateSupervisor.spawn(create, 'server/$index');
  await supervisor.resume();
  return supervisor;
}

Future<List<IsolateSupervisor>> startAll() async {
  var futures = List<Future<IsolateSupervisor>>.generate(__CONCURRENCY__, start);
  return await Future.wait<IsolateSupervisor>(futures);
}

Future<void> stop(IsolateSupervisor supervisor) async {
  await supervisor.stop();
}

Future<void> stopAll(List<IsolateSupervisor> supervisors) async {
  var futures = supervisors.map<Future<void>>(stop);
  await Future.wait<void>(futures);
}

String? getIsolateID(IsolateSupervisor supervisor) {
  return Service.getIsolateID(supervisor.isolate);
}

ServiceExtensionResponse okResponse({
  Map<String, Object?>? data,
  bool ok = false,
}) {
  data = <String, Object?>{'ok': ok, ...?data};
  return ServiceExtensionResponse.result(json.encode(data));
}

ServiceExtensionResponse errorResponse(
  Object error,
  StackTrace stackTrace, {
  bool ok = false,
}) {
  var data = <String, Object?>{
    'ok': ok,
    'error': error.toString(),
    'stackTrace': stackTrace.toString(),
  };

  return ServiceExtensionResponse.error(
    ServiceExtensionResponse.extensionError,
    json.encode(data),
  );
}

String trimRight(String message) {
  return message.trimRight();
}

extension on Application {
  void register() {
    Future<ServiceExtensionResponse> reload(
      String isolateId,
      Map<String, String> data,
    ) async {
      try {
        await this.reload();
        return okResponse();
      } catch (error, stackTrace) {
        return errorResponse(error, stackTrace);
      }
    }

    registerExtension('ext.astra.reload', reload);
  }
}

Future<void> main(List<String> arguments) async {
  try {
    var supervisors = await startAll();

    var isolateIDs = List<String?>.of(supervisors.map<String?>(getIsolateID));
    var data = <String, Object?>{'isolateIDs': isolateIDs};
    postEvent('ext.astra.started', data);

    var eventStream = stdin
        .transform<String>(utf8.decoder)
        .asyncMap<String>(trimRight);

    await for (var event in eventStream) {
      if (event == 'restart') {
        await stopAll(supervisors);
        supervisors = await startAll();
        postEvent('ext.astra.restarted', <String, Object?>{});
      } else if (event == 'stop') {
        await stopAll(supervisors);
        postEvent('ext.astra.stopped', <String, Object?>{});
        break;
      } else {
        throw UnsupportedError('event: $event');
      }
    }
  } catch (error, stackTrace) {
    stderr
      ..writeln(error)
      ..writeln(stackTrace);

    exitCode = 1;
  }
}

// generated by astra CLI __VERSION__ serve command.
//
// ignore_for_file: depend_on_referenced_packages
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: library_prefixes

import 'dart:async';
import 'dart:convert';
import 'dart:developer';
import 'dart:io';
import 'dart:isolate';

import 'package:astra/core.dart';
import 'package:astra/isolate.dart';
import 'package:astra/serve.dart';

import '__PACKAGE__' as _ show __TARGET__;

__CREATE__

ServiceExtensionResponse okResponse({
  Map<String, Object?> data,
  bool ok = false,
}) {
  data = <String, Object?>{'ok': ok, ...data};
  return ServiceExtensionResponse.result(json.encode(data));
}

ServiceExtensionResponse errorResponse(
  Object error,
  StackTrace stackTrace, {
  bool ok = false,
}) {
  var data = <String, Object?>{
    'ok': ok,
    'error': error.toString(),
    'stackTrace': stackTrace.toString(),
  };

  return ServiceExtensionResponse.error(
    ServiceExtensionResponse.extensionError,
    json.encode(data),
  );
}

extension on Application {
  void register() {
    Future<ServiceExtensionResponse> reload(
      String isolateId,
      Map<String, String> data,
    ) async {
      try {
        await this.reload();
        return okResponse();
      } catch (error, stackTrace) {
        return errorResponse(error, stackTrace);
      }
    }

    registerExtension('ext.astra.reload', reload);
  }
}

Future<void> main(List<String> arguments) async {
  var supervisors = <IsolateSupervisor>[];

  Future<List<String>> startAll() async {
    Future<String> start(int index) async {
      var receivePort = RawReceivePort();
      var isolate = await Isolate.spawn(create, receivePort.sendPort,
          paused: true, errorsAreFatal: false, debugName: 'isolate/$index');
      var supervisor = IsolateSupervisor(isolate, receivePort);
      supervisors.add(supervisor);
      await supervisor.resume();
    }

    var futures = <Future<List<String>>>[
      for (var i = 1; i <= 2; i += 1) start(i),
    ];

    return await Future.wait<String>(futures);
  }

  Future<void> stopAll() async {
    Future<void> stop(IsolateSupervisor supervisor) async {
      await supervisor.stop();
    }

    var futures = supervisors.map<Future<void>>(stop);
    await Future.wait<void>(futures);
  }

  var started = Completer<void>();

  registerExtension('ext.astra.start', (isolateId, params) async {
    if (started.isCompleted) {
      return okResponse(ok: false);
    }

    try {
      var isolateIds = await startAll();
      started.complete();

      var data = <String, Object?>{'isolateIds': isolateIds};
      return okResponse(data: data);
    } catch (error, stackTrace) {
      started.completeError(error, stackTrace);
      return errorResponse(error, stackTrace);
    }
  });

  var stopped = Completer<void>();

  registerExtension('ext.astra.stop', (isolateId, params) async {
    if (stopped.isCompleted) {
      return okResponse(ok: false);
    }

    try {
      await started.future;
      await stopAll();
      stopped.complete();
      return okResponse();
    } catch (error, stackTrace) {
      stopped.completeError(error, stackTrace);
      return errorResponse(error, stackTrace);
    }
  });

  var restarting = false;

  registerExtension('ext.astra.restart', (isolateId, params) async {
    if (restarting) {
      return;
    }

    restarting = true;

    try {
      await stopAll();
      await Future<void>.delayed(Duration.zero);
      supervisors = <IsolateSupervisor>[];
      await startAll();
      return okResponse();
    } catch (error, stackTrace) {
      return errorResponse(error, stackTrace);
    } finally {
      restarting = false;
    }
  });

  try {
    await stopped.future;
    exitCode = 0;
  } catch (error, stackTrace) {
    stderr
      ..writeln(error)
      ..writeln(stackTrace);

    exitCode = 1;
  }
}
